# Шаблоны генерации кода (codegen.json)

## Описание

Файл `codegen.json` содержит шаблоны для автоматической генерации кода инициализации и обработки периферийных устройств. Шаблоны используют синтаксис Mustache для подстановки переменных и поддерживают условную логику.

## Структура файла

Файл организован по типам периферийных устройств. Каждая периферия содержит секции для различных операций:

```json
{
  "peripheryName": {
    "init": {...},           // Инициализация периферии
    "interrupt": {...},       // Включение прерываний
    "isr": {...},            // Обработчики прерываний
    "modes": {...}           // Режимы работы (для GPIO)
  }
}
```

## Синтаксис шаблонов

### Переменные

Переменные в шаблонах обозначаются двойными фигурными скобками:

```
{{variableName}}
```

### Примеры переменных

- `{{pin.name}}` - имя пина (например, "PB1")
- `{{pin.ddr}}` - регистр направления данных (например, "DDRB")
- `{{pin.port}}` - регистр порта (например, "PORTB")
- `{{pin.pin}}` - регистр ввода (например, "PINB")
- `{{pin.bit}}` - номер бита в порту (например, 1)
- `{{baud}}` - скорость передачи
- `{{prescalerBits}}` - биты предделителя
- `{{channel}}` - канал таймера (A или B)

### Условная логика (Mustache)

```mustache
{{#condition}}
  // Код выполняется, если condition истинно
{{/condition}}

{{^condition}}
  // Код выполняется, если condition ложно
{{/condition}}
```

## Структура секций

### GPIO

```json
{
  "gpio": {
    "modes": {
      "INPUT": [...],           // Код для режима INPUT
      "INPUT_PULLUP": [...],    // Код для режима INPUT_PULLUP
      "OUTPUT_LOW": [...],      // Код для режима OUTPUT_LOW
      "OUTPUT_HIGH": [...]      // Код для режима OUTPUT_HIGH
    }
  }
}
```

### UART

```json
{
  "uart": {
    "init": {
      "async": [...],           // Инициализация асинхронного режима
      "sync": [...]             // Инициализация синхронного режима
    },
    "interrupts": {
      "RX": [...],              // Включение прерывания приёма
      "TX": [...],              // Включение прерывания передачи
      "UDRE": [...]            // Включение прерывания пустого буфера
    },
    "isr": {
      "RX": [...],              // Обработчик прерывания приёма
      "TX": [...],              // Обработчик прерывания передачи
      "UDRE": [...]            // Обработчик прерывания пустого буфера
    }
  }
}
```

### Таймеры

```json
{
  "timer1": {
    "init": {
      "normal": [...],          // Режим Normal
      "ctc": [...],            // Режим CTC
      "fast_pwm": [...],        // Режим Fast PWM
      "phase_correct_pwm": [...], // Режим Phase Correct PWM
      "input_capture": [...]    // Режим Input Capture
    },
    "interrupt": {
      "ovf": [...],            // Включение прерывания переполнения
      "compa": [...],          // Включение прерывания сравнения A
      "compb": [...],          // Включение прерывания сравнения B
      "capt": [...]            // Включение прерывания захвата
    },
    "isr": {
      "ovf": [...],            // Обработчик переполнения
      "compa": [...],          // Обработчик сравнения A
      "compb": [...],          // Обработчик сравнения B
      "capt": [...]            // Обработчик захвата
    }
  }
}
```

## Примеры использования

### Пример 1: GPIO режим INPUT_PULLUP

```json
{
  "gpio": {
    "modes": {
      "INPUT_PULLUP": [
        "{{pin.ddr}} &= ~(1 << {{pin.bit}}); // {{pin.name}} как INPUT",
        "{{pin.port}} |= (1 << {{pin.bit}}); // Включить подтяжку"
      ]
    }
  }
}
```

**Результат генерации для PB1:**
```c
DDRB &= ~(1 << 1); // PB1 как INPUT
PORTB |= (1 << 1); // Включить подтяжку
```

### Пример 2: UART инициализация

```json
{
  "uart": {
    "init": {
      "async": [
        "UBRR0H = (F_CPU / 16 / {{baud}} - 1) >> 8;",
        "UBRR0L = (F_CPU / 16 / {{baud}} - 1);",
        "UCSR0B = (1 << RXEN0) | (1 << TXEN0);",
        "UCSR0C = ({{parityBits}} << UPM00) | ({{stopBits}} << USBS0) | ({{dataBits}} << UCSZ00);"
      ]
    }
  }
}
```

**Результат генерации для 9600 бод:**
```c
UBRR0H = (F_CPU / 16 / 9600 - 1) >> 8;
UBRR0L = (F_CPU / 16 / 9600 - 1);
UCSR0B = (1 << RXEN0) | (1 << TXEN0);
UCSR0C = (0 << UPM00) | (0 << USBS0) | (3 << UCSZ00);
```

### Пример 3: Таймер Fast PWM

```json
{
  "timer1": {
    "init": {
      "fast_pwm": [
        "{{pin.ddr}} |= (1 << {{pin.bit}}); // {{pin.name}} ({{channel}}) как OUTPUT",
        "TCCR1A = (1 << WGM11) | (1 << WGM10) | (1 << COM1{{channel}}1);",
        "TCCR1B = (1 << WGM13) | (1 << WGM12) | ({{prescalerBits}} << CS10);",
        "OCR1{{channel}} = {{dutyCycle}};"
      ]
    }
  }
}
```

**Результат генерации для PB1, канал A, dutyCycle=128:**
```c
DDRB |= (1 << 1); // PB1 (A) как OUTPUT
TCCR1A = (1 << WGM11) | (1 << WGM10) | (1 << COM1A1);
TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS10);
OCR1A = 128;
```

### Пример 4: ADC с условной логикой

```json
{
  "adc": {
    "init": {
      "single": [
        "void adc_init() {",
        "    {{#channels}}",
        "    adc_init_single_channel({{channel}});",
        "    {{/channels}}",
        "}"
      ]
    }
  }
}
```

**Результат генерации для каналов [0, 1, 2]:**
```c
void adc_init() {
    adc_init_single_channel(0);
    adc_init_single_channel(1);
    adc_init_single_channel(2);
}
```

### Пример 5: Обработчик прерывания

```json
{
  "uart": {
    "isr": {
      "RX": [
        "ISR(USART_RX_vect) {",
        "    uint8_t data = UDR0;",
        "    // Обработка принятых данных",
        "}"
      ]
    }
  }
}
```

**Результат генерации:**
```c
ISR(USART_RX_vect) {
    uint8_t data = UDR0;
    // Обработка принятых данных
}
```

## Поддерживаемые периферии

Файл поддерживает следующие типы периферий:

- **gpio** - Настройка GPIO пинов
- **uart** - UART/USART интерфейс
- **spi** - SPI интерфейс
- **i2c** - I2C/TWI интерфейс
- **timer0, timer1, timer2** - Таймеры/счётчики
- **adc** - Аналого-цифровой преобразователь
- **external_interrupt** - Внешние прерывания (INT0, INT1)
- **pcint** - Прерывания изменения пина (Pin Change Interrupt)
- **analog_comparator** - Аналоговый компаратор
- **watchdog** - Сторожевой таймер

## Примечания

- Все шаблоны генерируют код на языке C для AVR микроконтроллеров.
- Имена регистров должны соответствовать определениям из заголовочных файлов AVR (например, `avr/io.h`).
- Переменные, используемые в шаблонах, должны быть предоставлены генератором кода на основе конфигурации пользователя.
- Комментарии в шаблонах помогают понять назначение каждой строки кода.
- Для таймеров переменная `{{channel}}` может быть "A" или "B" в зависимости от выбранного канала.

