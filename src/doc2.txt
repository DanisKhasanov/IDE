Ручная сборка hex-файла для AVR на основе ArduinoCore-avr.

Что понадобится
- avr-gcc (проверено на 15.2.0)
- avr-libc
- avrdude
- make
- git (для скачивания ядра)

1. Установка toolchain

Linux (Ubuntu/Debian):
sudo apt update
sudo apt install gcc-avr avr-libc avrdude

macOS:
bash
brew tap osx-cross/avr
brew install avr-gcc

 Windows:
- Рекомендуется использовать MSYS2 (https://www.msys2.org/):
  pacman -S mingw-w64-x86_64-avr-gcc mingw-w64-x86_64-avr-libc mingw-w64-x86_64-avrdude
- Или установить c Github (http://github.com/ZakKemble/avr-gcc-build).
> Необходимо убедиться, что путь к компилятору указан в Path в переменных среды.

Проверка:
avr-gcc --version
avr-objcopy --version
Должна вывестись версия компилятора.


2. Скачивание ядра Arduino

Скачай ArduinoCore-avr:
git clone https://github.com/arduino/ArduinoCore-avr.git

3. Структура проекта
Создай папку для проекта:
mkdir my_avr_project
cd my_avr_project
Скопируй нужные папки из ArduinoCore-avr:
cp -r ../ArduinoCore-avr/cores ./cores
cp -r ../ArduinoCore-avr/variants ./variants

Теперь структура должна быть такой:
my_avr_project/
├── src/
│   └── main.cpp          ← твой скетч
├── cores/
│   └── arduino/          ← ядро Arduino
│       ├── main.cpp      ← точка входа
│       ├── Arduino.h
│       └── ...
├── variants/
│   └── standard/         ← пины для Arduino Uno
│       └── pins_arduino.h
├── Makefile
└── build/                ← сюда будут помещаться .o и .hex

4. Пример исходного кода (src/main.cpp)

Создай src/main.cpp:
#include <Arduino.h>

void setup() {
    pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(1000);
    digitalWrite(LED_BUILTIN, LOW);
    delay(1000);
}

> LED_BUILTIN определён в pins_arduino.h для конкретной платы (например, Arduino Uno).
5. Написание Makefile

makefile
MCU = atmega328p
F_CPU = 16000000L
ARDUINO_VERSION = 10809

CC = avr-gcc
OBJCOPY = avr-objcopy
OBJDUMP = avr-objdump

CFLAGS = -g -Os -w -std=gnu11 -ffunction-sections -fdata-sections -MMD -MP -I$(CORE_DIR) -I$(VARIANT_DIR) -mmcu=$(MCU) -DF_CPU=$(F_CPU) -DARDUINO=$(ARDUINO_VERSION)
CXXFLAGS = -g -Os -w -std=gnu++11 -ffunction-sections -fdata-sections -fno-threadsafe-statics -MMD -MP -I$(CORE_DIR) -I$(VARIANT_DIR) -mmcu=$(MCU) -DF_CPU=$(F_CPU) -DARDUINO=$(ARDUINO_VERSION)
LDFLAGS = -Wl,--gc-sections

CORE_DIR = cores/arduino
VARIANT_DIR = variants/standard
BUILD_DIR = build

# Исходники ядра (включая main.cpp)
CORE_C = $(wildcard $(CORE_DIR)/*.c)
CORE_CPP = $(wildcard $(CORE_DIR)/*.cpp)

# Объектники ядра (с префиксом BUILD_DIR)
CORE_OBJ = $(CORE_C:$(CORE_DIR)/%.c=$(BUILD_DIR)/%.o) $(CORE_CPP:$(CORE_DIR)/%.cpp=$(BUILD_DIR)/%.o)

# Исходник приложения
APP_SRC = src/main.cpp
APP_OBJ = $(BUILD_DIR)/app_main.o  # ← ВАЖНО: не main.o, чтобы избежать конфликта

TARGET = firmware

all: $(BUILD_DIR)/$(TARGET).hex

# Компиляция приложения
$(APP_OBJ): $(APP_SRC)
	mkdir -p $(BUILD_DIR)
	$(CC) $(CXXFLAGS) -c $< -o $@

# Компиляция ядра
$(BUILD_DIR)/%.o: $(CORE_DIR)/%.c
	mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

$(BUILD_DIR)/%.o: $(CORE_DIR)/%.cpp
	mkdir -p $(BUILD_DIR)
	$(CC) $(CXXFLAGS) -c $< -o $@

# Линковка
$(BUILD_DIR)/$(TARGET).elf: $(APP_OBJ) $(CORE_OBJ)
	$(CC) $(LDFLAGS) -mmcu=$(MCU) -o $@ $(APP_OBJ) $(CORE_OBJ) -lm

# Генерация hex
$(BUILD_DIR)/$(TARGET).hex: $(BUILD_DIR)/$(TARGET).elf
	$(OBJCOPY) -O ihex -R .eeprom $< $@

clean:
	rm -rf $(BUILD_DIR)

.PHONY: all clean

Объяснение ключевых моментов:

- APP_OBJ = $(BUILD_DIR)/app_main.o — важно, чтобы имя объектного файла от src/main.cpp не совпадало с main.o от cores/arduino/main.cpp. Это предотвращает конфликт при линковке.
- CORE_CPP включает cores/arduino/main.cpp, который содержит int main(void) и вызывает setup() и loop().
- APP_SRC содержит setup() и loop(), но не содержит main().
- -mmcu=$(MCU) — передаётся при компиляции и линковке, чтобы компилятор знал, для какой архитектуры генерировать код.
- -I$(CORE_DIR) -I$(VARIANT_DIR) — указывает, где искать заголовочные файлы (Arduino.h, pins_arduino.h).

6. Сборка проекта

Выполни в терминале:

make

Результат:
- В папке build/ появятся:
  - app_main.o, main.o, wiring.o и другие .o файлы.
  - firmware.elf — исполняемый файл.
  - firmware.hex — готовый файл для заливки в МК.

7. Заливка прошивки (опционально)

Если подключена плата Arduino:
avrdude -v -p atmega328p -c arduino -P /dev/ttyUSB0 -b 115200 -U flash:w:build/firmware.hex

(Заменить /dev/ttyUSB0 на соответствующий порт, например, COM3 в Windows)

Светодиод на плате должен моргать с интервалом 1 секунда.

Важные файлы ядра Arduino

- cores/arduino/main.cpp — точка входа программы. Вызывает init(), setup(), loop().
- cores/arduino/wiring.c — реализация delay(), millis(), micros(), инициализация таймеров.
- cores/arduino/wiring_digital.c — реализация digitalWrite, digitalRead, pinMode.
- variants/standard/pins_arduino.h — маппинг пинов для Arduino Uno.

8. Подготовка библиотек (структура)

Для дальнейшего развития проекта (генератор периферии) можно создать папку libraries/:

my_avr_project/
├── libraries/
│   ├── UART/
│   │   ├── UART.h
│   │   └── UART.cpp
│   ├── SPI/
│   │   ├── SPI.h
│   │   └── SPI.cpp
│   └── ...

Каждая библиотека будет реализовывать инициализацию и работу с соответствующим модулем (UART, SPI и т.д.) на низком уровне.